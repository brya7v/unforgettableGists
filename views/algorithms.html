<h2 class="main-title">Algorithms</h2>

<div class="block">
    <def1>Recursion</def1>
    <p> Recursion is when a function that calls itself until it doesn't.</p>
    <p> - Each time the funciton calls itself its supposed to make the main problem smaller</p>

    <def2>Base case</def2>
    <p> Its the final case in the recursion, the one that makes the recursivity stop and returns the result.</p>
    <p> - If we don't have a base case we will have a <strong>stack overflow </strong> (infinity loop).</p>
    <p> - It requirea a return statement (otherwise the recursion will never end).</p>

    <def2>Recursive case</def2>
    <p> Case where we need to call the function again.</p>   
</div>


<div class="block">
    <def1>Call stack</def1>
    <p> When a function its called it enters the call stack, when it is completed it is removed from the called stack.</p>

    <p> When a function calls another function inside, this second function will be on top of the first one in the call stack, 
        so the seconf function has to be completed first, and then the first funtcion.</p>

    <def2>Factorial</def2>
    <p> 4! = 4 * 3 * 2 * 1 = 24</p>
    <p> 4! = 4 * 3! = 24</p>
    <p> 3! = 3 * 2! = 6</p>
    <p> 2! = 2 * 1! = 2</p>
    <p> 1! = 1</p>

    <div class="poblem-solution__container">
        <pre >
            function factorial(n){
                if(n == 1) return 1
                return n * factorial(n-1)
            }     
        </pre>
    </div>

    <p> - <strong> n=1 is the base case</strong></p>
    <p> - <strong> n>1 is the recursive case</strong></p>

    <p>Call stack will be something like:</p>
    <div class="poblem-solution__container">
        <pre >

            |            |
            |factorial(1)|     
            |factorial(2)|     
            |factorial(3)|     
            |factorial(4)|     
            --------------
        </pre>
    </div>
    <p>Where the last function to get in the stack is the first to get resolved. <strong>LIFO</strong></p>    
</div>

<div class="block">
    <def1>Bubble sort</def1>
    <p> Its the eassyest to explain of the sorting algorithms.</p>
    <p> - Its a very unneficient sorting algorithm.</p>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>
    <p> - Compares all the items 1 by 1 moving the greater element to the right and comparing it to the next, when we find the greater number
        it is move to the end of the array, the the comparation starts again but ignoring the last element (bc it is already sorted). </p>
    <p> - Al items are bubbled up to the top one by one.</p>

    <div class="poblem-solution__container">
        <pre >

            function bubbleSort(array){
                for(let i = array.length -1; i &gt 0; i-- ){
                    for(let j = 0; i &lt i; j++ ){
                        if(array[j] &gt array[j+1]){
                            let temp = array[j] 
                            array[j] = array[j+1] 
                            array[j] = temp
                        }
                    
                    }
                }
                return array
            }
        </pre>
    </div>
</div>


<div class="block">
    <def1>Selection sort</def1>
    <p> We've to keep track of the indexes.</p>
    <p> - We store the index of the first item in the min var.</p>
    <p> - Then we loop through the nex items searching for a lower than min value and store its index.</p>
    <p> - At the end we take that minimum and first item and switch them, so the first item of the array is in order.</p>
    <p> - Then we continue with the next not sorted item untill all of them are sorted.</p>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>

    <div class="poblem-solution__container">
        <pre >

            function selectionSort(array){               
                let min 
                for(let i = 0; i &lt array.length -1 ; i++ ){
                    min = i
                    for(let j = i+1; j &lt array.length; j++ ){
                        if(array[j] &lt array[min]){
                            min = j 
                        }

                        if(i!==min){
                            let temp = array[i]
                            array[i] = array[min] 
                            array[min] = temp                    
                        }
                    }
                }
                return array
            }
        </pre>
    </div>
</div>

<div class="block">
    <def1>Insertion sort</def1>
    <p> It allways starts with the second item and will compare it with the first.</p>
    <p> - If it is lower than the first we swap them and then move to the next index.</p>
    <p> - Then the next val is compared to the previous, if it is lower is swaped and then compared to the previous untill it is not lower or it reaches the start of the array.</p>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>

    <def2>BigO</def2>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>
    <p> - But when the starting array is almost sorted its complexity its almost O(n), so its best case scenario is proportional <strong>Ω(n)</strong>.</p>

    <div class="poblem-solution__container">
        <pre >

            function insertionSort(array){                
                let temp 
                for(let i = 1; i &lt array.length; i++){
                    temp = array[i] 
                    for(var j = i-1; array[j] &gt temp && j &gt -1; j--){
                        array[j+1] = array[j]
                    }
                    array[j+1] = temp
                }
                return array
            }
          
        </pre>
    </div>
</div>



<div class="block">
    <def1>Merge sort</def1>
    <p> It uses recursion.</p>
    <p> It takes the whole array and splits it in halfs untill there are only arrays with one value in it (wich is sorted),
        the combines two by two all tis arrays of one item untill we have only arrays with 2 items (wich are sorted),
        then again untill we only have arrays with 4 items (wich are sorted), and so on.</p>
    <p> It looks unneficient, but its as efficient as we can make a sorting algorithm.</p>


    <p> 1st it breks arrays in half.</p>
    <p> <strong>Recursion case </strong> it breks arrays in half.</p>
    <p> <strong>Base case </strong> when all arrays are lenght of 1.</p>

    
    <p> 2nd step it merges all arrays with the merge function.</p>
    <p> <strong>Recursion case </strong> we have more than 1 array left to merge.</p>
    <p> <strong>Base case </strong> all arrays are sorted into 1.</p>

    <div class="poblem-solution__container">
        <pre >
            function mergeSort(array){       
                
                if(array.lenght == 1) return array

                let mid = Math.floor(array.lenght/2)
                let left = array.slice(0, mid)
                let right = array(mid)

                return merge(mergeSort(left), mergeSort(right))                
            }
          
        </pre>
    </div>

    <def2>BigO</def2>
    <p> - Space complexity <strong>bigO(n)</strong>.</p>
    <p> - Time complexity - For breaking appart the arrays:<strong>bigO(log n)</strong>.</p>
    <p> - Time complexity - For merging the arrays:<strong>bigO(n)</strong>.</p>
    <p> - Time complexity - Total:<strong>bigO(n lon n)</strong>.</p>
    <p> - A complexity of O(n log n) (n times log n) its obviously worse than O(n) but slightly better than O(n²):<strong>bigO(n lon n)</strong>.</p>





    <def2>Merge</def2>
    <p> Its the main function of the merge sort algorithm.</p>
    <p> - It merges two <strong>SORTED</strong> arrays into one that is also sorted .</p>
    <p> - One array uses I and the other J, we compare them one by one and the lowest is pushed to a sorted array.</p>


    <div class="poblem-solution__container">
        <pre >
            function merge(array1, array2){                
                let combined = []
                let i = 0 
                let j = 0 
               
                while(i &lt array1.length && j &lt array2.length){
                    if(array1[i] &lt array2[j]){
                        combined.push(array1[i])
                        i++
                    } else {
                        combined.push(array2[j])
                        j++
                    }
                }

                while(i &lt array1.length){
                    combined.push(array1[i])
                    i++
                }
                
                while(j &lt array2.length){
                    combined.push(array2[j])
                    j++
                }

                return combined
            }
          
        </pre>
    </div>
</div>



<div class="block">

    <def1>Quick sort</def1>
    <p> We've a pivot point starting from the first item.</p>
    <p> Then it will be compared to every item in the array, if we found an item that is less than, we are going to exange it for the first item that is greater.</p>
    <p> At the end we swap the pivot element with the last item that is less than this.</p>
    <p> This way, at the left we have only elements lower than the pivot element, and at the right we've elements greater than the pivot element ('and this first pivot element will ve sorted').</p>
    <p> Then we will run quick sort on the left side of the first pivot point, and our new pivot point will be the first item.</p>
    <p> Then we will run quick sort on the right side of the first pivot point.</p>

    <p> - It uses <strong>recursion</strong> everytime a pivot element is sorted, the array is splited in a left and a right side, and the quick sort function is runed again.</p>

    <def2>Pivot</def2>
    <p> The pivot function is the escential function for the quick sort algorithm.</p>
    <p> It compares the first element of the array with all the others, if it founds an element lower, it will be swaped for the first element that is greater.</p>
    <p> It uses 3 variables: </p>
    <p><strong>Pivot</strong> points the pivot element(the first one). </p>
    <p><strong>Swap</strong> starts as the pivot. Everytime we have something smaller in I, we ++ the swap pointer and swap the value with I. </p>
    <p><strong>I</strong> Index that iterates over the whole array, comparing if the value is lower than the pivot, if it is, it is swaped with the swap index. </p>
    <p>At the end it will return the index of swap, so we can continue running quick sort from 0 to swap and from swap+1 to .length </p>

    <div class="poblem-solution__container">
        <pre >
            function swap(array, firstIndex, secondIndex){
                let temp = array[firstIndex]
                array[firstIndex] = array[secondIndex]
                array[secondIndex] = temp
            }

            function pivot(array, pivotIndex = 0, endIndex = array.length-1){
                let swapIndex = pivotIndex
                for(let i= pivotIndex +1; i &lt= endIndex; i++){
                    if(array[i] &lt array[pivotIndex]){
                        swapIndex++
                        swap(array, swapIndex, i)
                    }
                }
                
                swap(array, pivotIndex, swapIndex)
                return swapIndex
            }
          

            function quickSort(array, left=0, right = arra.lenth-1){
                if(left &lt right){
                    let pivotIndex = pivot(array, left, right)

                    quickSort(array, left, pivotIndex -1)
                    quickSort(array, pivotIndex+1, right)
                }
                return array
            }
        </pre>
    </div>

    <def2>Big O</def2>
    <p> From a space complexity it has a O(1) bc works over the same array, its an adventage over merge sort wich.</p>
    <p> It is good for random data.</p>
    <p> For almost sorted data it is better insertion sort.</p>
    <p> Time complexity best case Ω(n log n).</p>
    <p> Time complexity worst case is with already sorted data <strong>O(n log n)</strong>, there is no spliting of the array.</p>
</div>




<div class="block">

    <def1>Tree traversal</def1>
    <p> Traversing is going through each item form beginning to end and then returning an array with all the nodes.</p>
    <p> In a tree it is more complex, there are multiple ways to do this:</p>
    
    <p><strong>Breadth First Search</strong> Parent, then each child from left to right, then each child of each previous child from left to right until we go thorough all the nodes. </p>
    <p><strong>Depht First search</strong> We go from bottom left to up the right, the deepest node will be the one on the right </p>
     

    <def2>Breadth First Search</def2>
    <p> Start reading nodes from top to bottom from left to right.</p>
    <p> We start storing the first node into a queue array, and pass thist value to the results array.</p>
    <p> Every time the values are stored, the left and right props of the stored node are pushed into the queue array.</p>

    <div class="poblem-solution__container">
        <pre >
            Class BST{
                constructor(){
                    this.root = null
                }
            
                BFS(){
                    let currentNode = this.root
                    let queue = []
                    let results = []

                    queue.push(currentNode)

                    while(queue.length){
                        currentNode = queue.shift()
                        results.push(currentNode.value)
                        if(currentNode.left) queue.push(currentNode.left)
                        if(currentNode.right) queue.push(currentNode.right)
                    }
                }
                return results
            }
        </pre>
    </div>

    <def2>Deep First Search PreOrder</def2>
    <p>Top to bottom, from left to right.</p>

    <div class="poblem-solution__container">
        <pre >
            Class BST{
                constructor(){
                    this.root = null
                }
            
                DFSPreOrder(){
                    let results = []

                    function traverse(currentNode){
                        results.push(currentNode.value)
                        if(currentNode.left) traverse(currentNode.left)
                        if(currentNode.right) traverse(currentNode.right)
                    }
                    traverse(this.root)

                    return results
                }
            }
        </pre>
    </div>


    <def2>Deep First Search PostOrder</def2>
    <p>Top to bottom, from left to right, but the values are writed from last to first, so the root node will be the one on the array result.</p>

    <div class="poblem-solution__container">
        <pre >
            Class BST{
                constructor(){
                    this.root = null
                }
            
                DFSPreOrder(){
                    let results = []

                    function traverse(currentNode){
                        if(currentNode.left) traverse(currentNode.left)
                        if(currentNode.right) traverse(currentNode.right)
                        results.push(currentNode.value)
                    }
                    traverse(this.root)

                    return results
                }
            }
        </pre>
    </div>

    
    <def2>Deep First Search In Order</def2>
    <p>Start on the root, always go to the left untill theres a leaf and we write this value, then the parent then the right, so the result will be in ascending order.</p>

    <div class="poblem-solution__container">
        <pre >
            Class BST{
                constructor(){
                    this.root = null
                }
            
                DFSPreOrder(){
                    let results = []

                    function traverse(currentNode){
                        if(currentNode.left) traverse(currentNode.left)
                        results.push(currentNode.value)
                        if(currentNode.right) traverse(currentNode.right)
                    }
                    traverse(this.root)

                    return results
                }
            }
        </pre>
    </div>
    
    <strong>The three Deep First Search use the same code, just the results.push(currentNode.value) changes position depending on how we want the result to be. </strong>
</div>