<h2 class="main-title">Algorithms</h2>

<div class="block">
    <def1>Recursion</def1>
    <p> Recursion is when a function that calls itself until it doesn't.</p>
    <p> - Each time the funciton calls itself its supposed to make the main problem smaller</p>

    <def2>Base case</def2>
    <p> Its the final case in the recursion, the one that makes the recursivity stop and returns the result.</p>
    <p> - If we don't have a base case we will have a <strong>stack overflow </strong> (infinity loop).</p>
    <p> - It requirea a return statement (otherwise the recursion will never end).</p>

    <def2>Recursive case</def2>
    <p> Case where we need to call the function again.</p>   
</div>


<div class="block">
    <def1>Call stack</def1>
    <p> When a function its called it enters the call stack, when it is completed it is removed from the called stack.</p>

    <p> When a function calls another function inside, this second function will be on top of the first one in the call stack, 
        so the seconf function has to be completed first, and then the first funtcion.</p>

    <def2>Factorial</def2>
    <p> 4! = 4 * 3 * 2 * 1 = 24</p>
    <p> 4! = 4 * 3! = 24</p>
    <p> 3! = 3 * 2! = 6</p>
    <p> 2! = 2 * 1! = 2</p>
    <p> 1! = 1</p>

    <div class="poblem-solution__container">
        <pre >
            function factorial(n){
                if(n == 1) return 1
                return n * factorial(n-1)
            }     
        </pre>
    </div>

    <p> - <strong> n=1 is the base case</strong></p>
    <p> - <strong> n>1 is the recursive case</strong></p>

    <p>Call stack will be something like:</p>
    <div class="poblem-solution__container">
        <pre >

            |            |
            |factorial(1)|     
            |factorial(2)|     
            |factorial(3)|     
            |factorial(4)|     
            --------------
        </pre>
    </div>
    <p>Where the last function to get in the stack is the first to get resolved. <strong>LIFO</strong></p>    
</div>

<div class="block">
    <def1>Bubble sort</def1>
    <p> Its the eassyest to explain of the sorting algorithms.</p>
    <p> - Its a very unneficient sorting algorithm.</p>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>
    <p> - Compares all the items 1 by 1 moving the greater element to the right and comparing it to the next, when we find the greater number
        it is move to the end of the array, the the comparation starts again but ignoring the last element (bc it is already sorted). </p>
    <p> - Al items are bubbled up to the top one by one.</p>

    <div class="poblem-solution__container">
        <pre >

            function bubbleSort(array){
                for(let i = array.length -1; i &gt 0; i-- ){
                    for(let j = 0; i &lt i; j++ ){
                        if(array[j] &gt array[j+1]){
                            let temp = array[j] 
                            array[j] = array[j+1] 
                            array[j] = temp
                        }
                    
                    }
                }
                return array
            }
        </pre>
    </div>
</div>


<div class="block">
    <def1>Selection sort</def1>
    <p> We've to keep track of the indexes.</p>
    <p> - We store the index of the first item in the min var.</p>
    <p> - Then we loop through the nex items searching for a lower than min value and store its index.</p>
    <p> - At the end we take that minimum and first item and switch them, so the first item of the array is in order.</p>
    <p> - Then we continue with the next not sorted item untill all of them are sorted.</p>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>

    <div class="poblem-solution__container">
        <pre >

            function selectionSort(array){               
                let min 
                for(let i = 0; i &lt array.length -1 ; i++ ){
                    min = i
                    for(let j = i+1; j &lt array.length; j++ ){
                        if(array[j] &lt array[min]){
                            min = j 
                        }

                        if(i!==min){
                            let temp = array[i]
                            array[i] = array[min] 
                            array[min] = temp                    
                        }
                    }
                }
                return array
            }
        </pre>
    </div>
</div>

<div class="block">
    <def1>Insertion sort</def1>
    <p> It allways starts with the second item and will compare it with the first.</p>
    <p> - If it is lower than the first we swap them and then move to the next index.</p>
    <p> - Then the next val is compared to the previous, if it is lower is swaped and then compared to the previous untill it is not lower or it reaches the start of the array.</p>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>

    <def2>BigO</def2>
    <p> - Its for loop inside a for loop, so its <strong>bigO(n²)</strong>.</p>
    <p> - But when the starting array is almost sorted its complexity its almost O(n), so its best case scenario is proportional <strong>Ω(n)</strong>.</p>

    <div class="poblem-solution__container">
        <pre >

            function insertionSort(array){                
                let temp 
                for(let i = 1; i &lt array.length; i++){
                    temp = array[i] 
                    for(var j = i-1; array[j] &gt temp && j &gt -1; j--){
                        array[j+1] = array[j]
                    }
                    array[j+1] = temp
                }
                return array
            }
          
        </pre>
    </div>
</div>



<div class="block">
    <def1>Merge sort</def1>
    <p> It uses recursion.</p>
    <p> It takes the whole array and splits it in halfs untill there are only arrays with one value in it (wich is sorted),
        the combines two by two all tis arrays of one item untill we have only arrays with 2 items (wich are sorted),
        then again untill we only have arrays with 4 items (wich are sorted), and so on.</p>
    <p> It looks unneficient, but its as efficient as we can make a sorting algorithm.</p>


    <p> 1st it breks arrays in half.</p>
    <p> <strong>Recursion case </strong> it breks arrays in half.</p>
    <p> <strong>Base case </strong> when all arrays are lenght of 1.</p>

    
    <p> 2nd step it merges all arrays with the merge function.</p>
    <p> <strong>Recursion case </strong> we have more than 1 array left to merge.</p>
    <p> <strong>Base case </strong> all arrays are sorted into 1.</p>

    <div class="poblem-solution__container">
        <pre >
            function mergeSort(array){       
                
                if(array.lenght == 1) return array

                let mid = Math.floor(array.lenght/2)
                let left = array.slice(0, mid)
                let right = array(mid)

                return merge(mergeSort(left), mergeSort(right))                
            }
          
        </pre>
    </div>

    <def2>BigO</def2>
    <p> - Space complexity <strong>bigO(n)</strong>.</p>
    <p> - Time complexity - For breaking appart the arrays:<strong>bigO(log n)</strong>.</p>
    <p> - Time complexity - For merging the arrays:<strong>bigO(n)</strong>.</p>
    <p> - Time complexity - Total:<strong>bigO(n lon n)</strong>.</p>
    <p> - A complexity of O(n log n) (n times log n) its obviously worse than O(n) but slightly better than O(n²):<strong>bigO(n lon n)</strong>.</p>





    <def2>Merge</def2>
    <p> Its the main function of the merge sort algorithm.</p>
    <p> - It merges two <strong>SORTED</strong> arrays into one that is also sorted .</p>
    <p> - One array uses I and the other J, we compare them one by one and the lowest is pushed to a sorted array.</p>


    <div class="poblem-solution__container">
        <pre >
            function merge(array1, array2){                
                let combined = []
                let i = 0 
                let j = 0 
               
                while(i &lt array1.length && j &lt array2.length){
                    if(array1[i] &lt array2[j]){
                        combined.push(array1[i])
                        i++
                    } else {
                        combined.push(array2[j])
                        j++
                    }
                }

                while(i &lt array1.length){
                    combined.push(array1[i])
                    i++
                }
                
                while(j &lt array2.length){
                    combined.push(array2[j])
                    j++
                }

                return combined
            }
          
        </pre>
    </div>
</div>