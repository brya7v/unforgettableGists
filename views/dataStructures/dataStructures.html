<h2 class="main-title">Data structures</h2>

<div class="block">
    <def1>Code efficiency</def1>
    <p>There are two approaches when we want to measure the efficiency of a code: </p>
    <ul>
        <li><strong>Time efficiency (defined by the Time complexity).</strong></li>
        <li><strong>Memory efficiency (defined by the Space complexity).</strong></li>
    </ul>
      </p>
    <ul>
        <li><def2>Time complexity</def2> We don't measure tieme complexity in time (bc it depends on the hardware), instead it's measured 
            in the number of opeations.        
        </li>
        <li><def2>Space complexity</def2> It's the ammount of memory that something uses.
    </ul>
</div>

<div class="block">
    <def1>Big O</def1>
    <p>Is a way to mathematically figure out wich of two codes is better (wich one runs more efficiently). <strong> With Big O we measeure both (Time and space complexity).</strong></p>
    <ul>
        <li>
            <def2>Omega Ω</def2> <p> Best case scenario for a code to resolve a problem.</p>
            <def2>Theta Θ</def2> <p> Average case scenario for a code to resolve a problem.</p>
            <def2>Omicron Ο</def2> <p> Also called O or BigO - Its the worst case scenario for a code to resolve a problem.</p>
        </li>
        
    </ul>
</div>


<div class="block">
    <def1>Big O Notation</def1>
    <p>It defines the complexity of the code.</strong></p>
    <ul>
        <li>
            <def2>O(n)</def2> 
            <ul>
                <li> Proportional complexity.</li>
                <li> We pass n to the function, and it runs n times.
                    <div class="poblem-solution__container">
                        <pre >
    function logItems(n){
        for(let i=0; i&ltn; i++){
            console.log(i)
        }
    }     
                        </pre>
                    </div>
                </li>
                <li> It's a simple for loop that runs n times.</li>
                <li> The number of operations its proportional to n.</li>
                <li> if we had 2 loops (one after another) the complexity will be <strong>O(2n)</strong> but we drop constants when defining the complexity,
                    so the complexity still is <strong>O(n)</strong>.</li>
                </li>  
                    
                <li> In this example, the BigO notation will be O(a+b).
                    <div class="poblem-solution__container">
                        <pre >
    function logItems(a,b){
        for(let i=0; i&lta; i++){
            console.log(i)
        }
        for(let i=0; i&ltb; i++){
            console.log(i)
        }
    }     
                        </pre>
                    </div>
                </li>  
            </ul>
        </li>
        <li>
            <def2>O(n²)</def2> 
            <ul>
                <li> Loop within a loop.</li>
                <li> Whe pass n to the function, and it runs a for inside a for so its notation will be O(n * n) = O(n²).
                    <div class="poblem-solution__container">
                        <pre >
    function logItems(n){
        for(let i=0; i&ltn; i++){
            for(let j=0; j&ltn; j++){
                console.log(i,j)
            }
        }
    }     
                        </pre>
                    </div>
                </li>
                <li> If we had 3 nested for loops, its BigO notation will be O(n * n * n) = O(n³).</li>
                <li> <strong>It doesn't matter if the notation is O(n into the 2, 3, 4, 5) we are still going to wite it as O(n²).</strong></li>        
                <li> In this example, the BigO notation will be O(a*b). 
                    <div class="poblem-solution__container">
                        <pre >
    function logItems(a,b){
        for(let i=0; i&lta; i++){
            for(let j=0; j&ltb; j++){
                console.log(i,j)
            }
        }
    }     
                        </pre>
                        
                    </div>
                </li>  
                <li><strong>When we can, we must use the different terms of inputs to define the BigO notation.</strong></li>
            </ul>
            <def3>Drop dominants</def3>
            <p>If we have a nested for loop followed by a for loop, the BigO notation will be somehthing like: <strong>O(n²) + O(n) = O(n² + n) </strong>, we have to drop the non dominant notation. So te actual BigO notation is O(n²)</p>
        </li>
        <li>
            <def2>O(1)</def2> 
            <ul>
                <li>Also refered as constant time complexity.</li>
                <li> We pass n to the function, and it runs 1 time. 
                    <div class="poblem-solution__container">
                        <pre >
    function logItems(n){
        return n+n
    }     
                        </pre>
                    </div>
                </li>
                <li>If we had the following code where there are 2 operations, the notation will be O(2), but we just simplify it and call it O(1).
                    <div class="poblem-solution__container">
                        <pre >
    function logItems(n){
        return n + n + n
    }     
                        </pre>
                    </div>
                </li>
            </ul>
        </li>
        <li>
            <def2>O(log n)</def2> 
            <ul>
                <li> Its when we work with and sorted array using the technique <strong>divide and conquer</strong>.<li>
                <li> For example when searching for an specific number in a sorted array, we can split the array in half, then a condition to see in wich half the number we are searching could be, then we repeat the process: <strong>divide and conquer</strong>.<li>
                <li> If we have an array of lenght 8 we can find any item in just 3 steps, why? <strong>divide and conquer</strong>.
                    <div class="poblem-solution__container">
                        <pre >
    arr = [1, 2, 3, 4, 5, 6, 7, 8]
    if we are looking for the num 1, we divide 1 time and determine where the num can be

    *1st op: firstHalf = [1, 2, 3, 4] secondHalf = [5, 6 ,7 ,8]

    it could be in the first, so then enw arr =[1 2, 3, 4] , so we split the array again

    *2nd op: firstHalf = [1, 2] secondHalf = [4, 5]

    arr = [1, 2] and we split again

    *3rd op: firstHalf = [1] secondHalf = [2]

    and we find the numer 1 in the first array in just 3 ops.
                        </pre>
                        
                    </div>
                </li>
                <li> To calculate the number of operations required to find a number in a sorted array, we just <strong>log base2(n)</strong>.<li>
                    <div class="poblem-solution__container">
                        <pre >  
    arr = [1, 2, 3, 4, 5, 6, 7, 8] 

    arr.length = 8
    operations = log base2 (8) = 3
    bc 2³ = 8

    if arr.length = 1073741824       
    operations = log base2 (1073741824) = 30
    bc 2^30 = 1073741824
    
    ∴ operations = log base 2(n)
    bc 2^operations = n (where n = arr.lenght)
                        </pre>
                    </div>
            </ul>
        </li>
        <li> Althoug log withot a base represents log base10, in the bigO notation we just represent lig base2 as log, so this notation is writhed: <strong>O(log n)</strong>.</li>

    </ul>
    </ul>
</div>

<div class="block">
    <def1>Pointers</def1>
    <p><strong>Variables that are reference to a space in memory instead of a value..</strong></p>
    <p>All of the data structures use pointers</p>
    <ul>
        <li>

            <div class="poblem-solution__container">
                <pre >  
    **NOT USING POINTERS
    let num1 = 43
    let num2 = num1
    *log* num2 = 43

    num1 = 22
    *log* num2 = 43

    **USING POINTERS
    let obj1 = {value: 32}
    let obj2 = obj1
    *log* obj2 = {value = 32}

    obj1.value = 66
    *log* obj2 = {value = 66}

    *both objects point to the same object
                </pre>
            </div>
        </li>
        <li>
            <def2>JS garbage collector</def2>
            <p>If we point some variables that used to be a refference of an object to another object, the object that is not beign used 
                by any variable is still using memory but we can't access to it, Js periodically uses the garbage collector to clean things like this.</p>
                <div class="poblem-solution__container">
                    <pre >  
        obj3 = {val: 9}

        if we:
        obj1=obj3
        obj2=obj3

        **the old obj1 object ( {value = 66} ) will still be in the memory untill the Js garbage collector cleans it.
                    </pre>
                </div>
        </li>
    </ul>
</div> 

<!-- arrays list -->
<div w3-include-html="views/dataStructures/arrays.html"></div>

<!-- linked list -->
<div w3-include-html="views/dataStructures/linkedLists.html"></div>

<!-- doubly linked list -->
<div w3-include-html="views/dataStructures/doublyLinkedLists.html"></div>

<!-- stacks -->
<div w3-include-html="views/dataStructures/stacks.html"></div>

<!-- queue -->
<div w3-include-html="views/dataStructures/queues.html"></div>

<!-- trees -->
<div w3-include-html="views/dataStructures/trees.html"></div>

<!-- hashTables -->
<div w3-include-html="views/dataStructures/hashTables.html"></div>

<!-- graphs -->
<div w3-include-html="views/dataStructures/graphs.html"></div>