<div class="block">
    <def1>Hash tables</def1>
    <p>Js already has an implementation of hast tables:<strong>objects.</strong></p>
    <p><strong>{nails: 1000}.</strong> example.</p>
    <p><strong>Key: nails.</strong>.</p>
    <p><strong>Value: 1000.</strong>.</p>
    <p>Then, he key is run through a <strong>Hash</strong> wich is a math equation, to create a number and store it in memory.</p>
    <p>When we try to access this key, it is again runned through the <strong>Hash</strong> so we know where to access to get the value.</p>
    <p><strong>Hash</strong>When we try to access this key, it is again runned through the <strong>Hash</strong> so we know where to access to get the value.</p>
    <p>The number generated by the hasy is the 'direction' where the key value will be stored.</p>

    <def2>Hash</def2>
    <p><strong>One way</strong> we can give it a key to get a number, but can't give a num to get the key.</p>
    <p><strong>Deterministic</strong> the same input will always produce the same number.</p>

    <p><strong>Deterministic</strong> the same input will always produce the same number.</p>
    
    <p><strong>collision</strong> When the output of the hash is the same for different hashtables, 'there will be a collision',
         the memery location will store both key values.</p>

    <p><strong>Get</strong> runs the key through the hash to get the memory position of the value, if the mem positiion has more than one value stored, compares the original
        key string to find the corresponding value to return.</p>


    <def2> Collission </def2>
    <p><strong>Collissions</strong> its when we have an item that maps to the same spot in memory.</p>
    <p><strong>Separate chaining</strong> aproach to handle collissions, stores in the same memory space in an 'array chain of the key value pairs'.</p>
    <p><strong>Line probing</strong> check the next memory space to check if its open and store it there, if its not empty goes to the next.</p>



    <def2>
        BigO
    </def2>
    <p>If all the hashes point to the same memory space that would be our worst case scenarion so we could say O(n)</p> 
    <p>But when we are dealing with hash tables, for example the build in object in javascript, the hash randomization is more effective 
        so the collission are more rare. So, findong something is <strong>O(1)</strong>
    </p>  

    <p><strong>Set O(1).</strong></p>
    <p><strong>Get O(1).</strong></p>
    <p><strong>Remove O(1).</strong></p>
    <br>
    
    <p><strong>Constructor</strong> It requiers the _hash function to get the memory location of each key</p>


    <div class="poblem-solution__container">
        <pre >  
            Class HashTable{
                constructor(size = 7){
                    this.dataMap = new Array(size)
                }

                // the _function are methods thar should only be called by other methods, you should not be calling these directly
                _hash(key){
                    let hash = 0
                    for (let i = 0; i &lt key.length; i++){
                        hash = (hash + key.charCodeAt(i) *23) % this.dataMap.length
                    }
                    return hash // will be 0 to 6 bc the array size is 7, so the % this.dataMap.length result cannot be more than 6
                }
            }
        </pre>
    </div>
    <ul>
        <li>
            <def2>Set</def2> 
            <ul>
                <li> Stores the key value pair in the specific memory space determined by the hash, if there is a collission it is resolved by
                    separate chaining.</li>
            </ul>
            <div class="poblem-solution__container">
                <pre >  
                    set(key, value){
                        let index = this._hash(key)

                        if(!this.dataMap[index]) this.dataMap[index] = []

                        this.dataMap[index].push([key, value])
                        
                        return this
                    }
                </pre>
            </div>
        </li>
        <li>
            <def2>Get</def2> 
            <ul>
                <li> Returns the value of the specific key. If it doesnt exists returns undefined</li>
            </ul>
            <div class="poblem-solution__container">
                <pre >  
                    get(key, value){
                        let index = this._hash(key)

                        if(this.dataMap[index]){
                            for (let i = 0; i &lt this.dataMap[index].length; i++){
                                if(this.dataMap[index][i] === key) this.dataMap[index][i][1]
                            }                            
                        } 
                        return undefined
                    }
                </pre>
            </div>
        </li>
        <li>
            <def2>Keys</def2> 
            <ul>
                <li>Returns all of the hashtables that are in the hastable and return them in an array.</li>
            </ul>
            <div class="poblem-solution__container">
                <pre >  
                    keys(){
                        let keys = []

                        for (let i = 0; i &lt this.dataMap.length; i++){
                            if(this.dataMap[i]){
                                for (let j = 0; j &lt this.dataMap[i].length; j++){
                                    keys.push(this.dataMap[i][j][0])
                                }   
                            }
                        }   
                        return keys
                    }
                </pre>
            </div>
        </li>
    </ul>
</div>