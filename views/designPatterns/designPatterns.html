<h2 class="main-title">Design Patterns</h2>

<div class="block">
    <def1>Design Patterns</def1>
    <ul>
        <li>Design Patterns are nothing more than common architectural approeaches. </li>
        <li>Popularized by the Gang of four book 1994 for c++</li>
        <li>They are universally relevant, some languages have them internalized in itslefs </li>
    </ul>
</div>

<div class="block">
    <def1>SOLID</def1>
    <ul>
        <li>It's an acronym that describes the fundamental principles of object orientend programming</li>
        <li>Introduced by Robert C. Martin aka uncle Bob</li>
        <li><def2>The 5 SOLID principles</def2></li>
        <li>
            <ul>
                
                <li><strong>S</strong> - Single Responsibility Principle (SRP)</li>
                <li><strong>O</strong> - Open/Closed Principle (OCP)</li>
                <li><strong>L</strong> - Liskov Substitution Principle (LSP)</li>
                <li><strong>I</strong> - Interface Segregation Principle (ISP)</li>
                <li><strong>D</strong> - Dependency Inversion Principle (DIP)</li>

            </ul>

        </li>
    </ul>
</div>


<div class="block">
    <def1>Single Responsibility Principle (SRP)</def1>
    <p>A class should have a single primary Responsibility and as a consequence it should only have one reason to change, that reason
        beign somehow related to its Responsibility, in other words <strong>it's a bad idea to add more than Responsibilityto a class</strong>
    </p>
    <p>In the next class example, the class Journal has only one job: handling entries</p>
    <div class="poblem-solution__container">
        <pre>  

            //import requires a npm project based to work

            import fs from 'fs'
            class Journal
            {
                constructor(){
                    this.entries = {}
                }

                addEntry(text){
                    let c = ++Journal.count
                    let entry = `${c}: ${text}`
                    this.entries[c] = entry
                    return c
                }

                removeEntry(index){
                    delete this.entries[index]
                }

                toString(){
                    return Object.values(this.entries).join('\n')
                }



                //THIS  FUNCTIONS SHOULDN'T BE IN THE SAME CLASS, WE SHOULD ADD ANOTHER CLASS FOR PERSISTENCE
                save(filename){
                    fs.writeFileSync(filename, this.toString())
                }

                load(filename){

                }
                loadFromUrl(url){

                }
            }
            Journal.count = 0

            let j = new Journal()
            j.addEntry('test entry number one')
            j.addEntry('second entry')
            j.addEntry('another entry ')

            console.log(j.toString())
        </pre>
    </div>

    <p>Instead of the Journal class doing the files related stuff, we should have another class that can handle that files related stuff
        in a general way, so we can work with the Journal class or others that we may use in the future, instead of each Journal type class
        having it's own file management methods inside.
    </p>
    <br>
    <p>This way, if our files are not beign saved properly, we don't have to look the specific class to find the problem, we just have to checkit
        in the PersistenceManager class
    </p>
    <div class="poblem-solution__container">
        <pre>  
            class PersistenceManager{

                preprocess(journal){
                    
                }

                saveToFile(journal, filename){
                    fs.writeFileSync(filename, this.toString())
                }
            }

            let p = new PersistenceManager()
            let filename = 'c:/temp/journal.txt'

            p.saveToFile(j, filename)
        </pre>
    </div>
    <def2>Separation of concerns</def2>
    <p>Separation of functionalities / responsibilities into different objects / classes, so the code becomes easier to work with, easier to refactor, debug, etc. 

    </p>
</div>


<div class="block">
    <def1>Open/Closed Principle (OCP)</def1>

    <p>States that objects are open for extension, but close for modification</p>
    <p>It's preferable to add new functionalities by creating them into new Clases instead of modifying an existing one bc it can generate problems due to it
        beign implemented in other codes, or it will require modifications in unit testing code, etc. </p>

    <strong>We never jump to an existing class and modify it, we should create a new one.</strong>
    <div class="poblem-solution__container">
        <pre>  

            let Color = Object.freeze({
                red: 'red',
                green: 'green',
                blue: 'blue'
            })

            
            let Size = Object.freeze({
                small: 'small',
                medium: 'medium',
                large: 'large'
            })


            class Product{
                constructor(name, color, size){
                    this.name = name
                    this.color = color
                    this.size = size
                }
            }

            class ProductFilter{
                filterByColor(products, color){
                    return products.filter(p => p.color === color)
                }

                filterBySize(products, size){
                    return products.filter(p => p.size === size)
                }

                //IF WE CONTINUE ADDING FILTER METHODS, WE'LL HAVE SOMETHING CALLED: STATE SPACE EXPLOSION
                //ITS NOT PRACTICAL TO WRITE ONE FILTER FOR EACH SPECIFIC SEARCH CASE

                //EACH FILTER SHOULD BE IN A SEPARATED CLASS

                filterBySizeAndColor(products, size, color){
                    return products.filter(p => p.size === size && p.color === color)
                }
            }

            let apple = new Product('Apple', Color.green, Size.small)
            let tree = new Product('Tree', Color.green, Size.large)
            let house = new Product('House', Color.blue, Size.large)

            let products = [apple, tree, house]

            let pf = new ProductFilter()

            console.log(`Green products (bad approach):`)
            for(let p of pf.filterByColor(products, Color.green)){
                console.log(` * ${p.name} is green`)
            }

        </pre>
    </div>

    <def2>State space explosion</def2>
    <p>For this example, we started with the filterByColor, then added filterBySize, then filterByColorAndSize, it's not practical to write all combinations 
        for the search cases, this will create a sate space explosion.
    </p>
    <def3>Specification pattern</def3>
    <p>This patter takes us away from the state space explosion methods, wich allow us to write something more easeir to work with</p>
    <p>If we have each filter in a separated class, if then we need to add more filters we don't have to modify the already existing classes, we just create a brand new class
        and implement it where it's needed (OPEN FOR NEW ADDITIONS, CLOSED FOR MODIFICATIONS)
    </p>

    <div class="poblem-solution__container">
        <pre>  
            class ColorSpecification{
                constructor(color){
                    this.color = color
                }

                isSatisfied(item){
                    return item.color === color
                }
            }

            class SizeSpecification{
                constructor(size){
                    this.size = size
                }

                isSatisfied(item){
                    return item.size === size
                }
            }

            class BetterFilter{
                filter(items, spec){
                    return items.filter(x=> spc.isSatisfied(x))
                }
            }

            let bf = new BetterFilter()
            console.log(`Green products (good approach):`)
            for(let p of bf.filter(products, 
                new ColorSpecification(Color.green))){
                console.log(` * ${p.name} is green`)
            }
        </pre>
    </div>
    <div class="poblem-solution__container">
        <pre>  

            //COMBINATOR WITH AN AND SPECIFICATION - HOW IT SHOULD BE DONE FOLLOWING THE OPEN/CLOSE PRINCIPLE
            console.log('Large and Green prods:')
            let spec = new AndSpecification(
                new ColorSpecification(Color.green),
                new SizeSpecification(Size.large)
            )
            for(let p of bf.filter(products, spec)){
                console.log(` * ${p.name} is large and green`)
            }

            //FOR MULTIPLE FILTERS WE SHOULD ADD A MULTIPLIER

            class AndSpecification{
                constructor(...specs)
                {
                    this.specs = specs
                }

                isSatisfied(item){
                    return this.specs.every(x => x.isSatisfied(item))
                }
            }

            //THERE ALSO CAN BE OrSpecification, 
        </pre>
    </div>

    <strong>Typically in object oriented programming the Specification classes would have some sort of abstract class</strong>
    <p>In js there are no abrstract classes but we can force it into the constructor</p>
    <p>An abstract class defines methods but not its implementation, it does not have a constructor, its just used to be extended from other clases </p>
    <div class="poblem-solution__container">
        <pre>  
            class Specification{
                constructor(){
                    if(this.constructor.name === 'Specification')
                    throw new Error('Specification is abstract!')
                }

                isSatisfied(item){

                }
            }

            Class ColorSpecification extends Specification {


            }
        </pre>
    </div>

</div>



<div class="block">
    <def1>Patterns</def1>
    <ul>
        <li>There are 3 main types of SOLID sesign patterns categories</li>


        <li><def2>Creational</def2></li>
        <li>
            <ul>
                <li><strong>Builder</strong> - </li>
                <li><strong>Factories</strong> -  
                    <ul>
                        <li><strong>Abstract Factory</strong> - </li>
                        <li><strong>Factory Method</strong> - </li>
                    </ul>
                </li>
                <li><strong>Prototype</strong> - </li>
                <li><strong>Singleton</strong> - </li>
            </ul>
        </li>

        <li><def2>Structural</def2></li>
        <li>
            <ul>
                <li><strong>Adapter</strong> - </li>
                <li><strong>Bridge</strong> -  </li>
                <li><strong>Composite</strong> - </li>
                <li><strong>Decorator</strong> - </li>
                <li><strong>Façade</strong> - </li>
                <li><strong>Flywheight</strong> - </li>
                <li><strong>Proxy</strong> - </li>
            </ul>
        </li>

        <li><def2>Behavioral</def2></li>
        <li>
            <ul>
                <li><strong>Chain of Responsibility</strong> - </li>
                <li><strong>Command</strong> -  </li>
                <li><strong>Interpreter</strong> - </li>
                <li><strong>Iterator</strong> - </li>
                <li><strong>Mediator</strong> - </li>
                <li><strong>Memento</strong> - </li>
                <li><strong>Observer</strong> - </li>
                <li><strong>State</strong> - </li>
                <li><strong>Strategy</strong> - </li>
                <li><strong>Template Method</strong> - </li>
                <li><strong>Visitor</strong> - </li>
            </ul>
        </li>
    </ul>
</div>

<div class="block">
    <def1>AntiPatterns</def1>
    <ul>
        <li><strong>GodObject</strong> Huge class with lots of Responsibilities, lots of spaggety code difficult to figure it out</li>
    </ul>
</div>
